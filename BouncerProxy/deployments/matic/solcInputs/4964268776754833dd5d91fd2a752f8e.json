{
  "language": "Solidity",
  "sources": {
    "contracts/BouncerProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.4.22 <0.9.0;\r\n/*\r\n  Bouncer identity proxy that executes meta transactions for etherless accounts.\r\n\r\n  Purpose:\r\n  I wanted a way for etherless accounts to transact with the blockchain through an identity proxy without paying gas.\r\n  I'm sure there are many examples of something like this already deployed that work a lot better, this is just me learning.\r\n    (I would love feedback: https://twitter.com/austingriffith)\r\n\r\n  1) An etherless account crafts a meta transaction and signs it\r\n  2) A (properly incentivized) relay account submits the transaction to the BouncerProxy and pays the gas\r\n  3) If the meta transaction is valid AND the etherless account is a valid 'Bouncer', the transaction is executed\r\n      (and the sender is paid in arbitrary tokens from the signer)\r\n\r\n  Inspired by:\r\n    @avsa - https://www.youtube.com/watch?v=qF2lhJzngto found this later: https://github.com/status-im/contracts/blob/73-economic-abstraction/contracts/identity/IdentityGasRelay.sol\r\n    @mattgcondon - https://twitter.com/mattgcondon/status/1022287545139449856 && https://twitter.com/mattgcondon/status/1021984009428107264\r\n    @owocki - https://twitter.com/owocki/status/1021859962882908160\r\n    @danfinlay - https://twitter.com/danfinlay/status/1022271384938983424\r\n    @PhABCD - https://twitter.com/PhABCD/status/1021974772786319361\r\n    gnosis-safe\r\n    uport-identity\r\n\r\n*/\r\n\r\n\r\n//use case 1:\r\n//you deploy the bouncer proxy and use it as a standard identity for your own etherless accounts\r\n//  (multiple devices you don't want to store eth on or move private keys to will need to be added as Bouncers)\r\n//you run your own relayer and the rewardToken is 0\r\n\r\n//use case 2:\r\n//you deploy the bouncer proxy and use it as a standard identity for your own etherless accounts\r\n//  (multiple devices you don't want to store eth on or move private keys to will need to be added as Bouncers)\r\n//  a community if relayers are incentivized by the rewardToken to pay the gas to run your transactions for you\r\n//SEE: universal logins via @avsa\r\n\r\n//use case 3:\r\n//you deploy the bouncer proxy and use it to let third parties submit transactions as a standard identity\r\n//  (multiple developer accounts will need to be added as Bouncers to 'whitelist' them to make meta transactions)\r\n//you run your own relayer and pay for all of their transactions, revoking any bad actors if needed\r\n//SEE: GitCoin (via @owocki) wants to pay for some of the initial transactions of their Developers to lower the barrier to entry\r\n\r\n//use case 4:\r\n//you deploy the bouncer proxy and use it to let third parties submit transactions as a standard identity\r\n//  (multiple developer accounts will need to be added as Bouncers to 'whitelist' them to make meta transactions)\r\n//you run your own relayer and pay for all of their transactions, revoking any bad actors if needed\r\n\r\ncontract BouncerProxy {\r\n  //whitelist the deployer so they can whitelist others\r\n  constructor() {\r\n     whitelist[msg.sender] = true;\r\n  }\r\n  //to avoid replay\r\n  mapping(address => uint) public nonce;\r\n  // allow for third party metatx account to make transactions through this\r\n  // contract like an identity but make sure the owner has whitelisted the tx\r\n  mapping(address => bool) public whitelist;\r\n  event UpdateWhitelist(address _account, bool _value);\r\n  function updateWhitelist(address _account, bool _value) public returns(bool) {\r\n   require(whitelist[msg.sender],\"BouncerProxy::updateWhitelist Account Not Whitelisted\");\r\n   whitelist[_account] = _value;\r\n   emit UpdateWhitelist(_account,_value);\r\n   return true;\r\n  }\r\n  \r\n  // copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol\r\n//   function () public payable { emit Received(msg.sender, msg.value); }\r\n//   event Received (address indexed sender, uint value);\r\n\r\n  function getHash(address signer, address destination, uint value, bytes memory data, address rewardToken, uint rewardAmount) public view returns(bytes32){\r\n    return keccak256(abi.encodePacked(address(this), signer, destination, value, data, rewardToken, rewardAmount, nonce[signer]));\r\n  }\r\n\r\n\r\n  // original forward function copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol\r\n  function forward(bytes memory sig, address signer, address destination, uint value, bytes memory data, address rewardToken, uint rewardAmount) public {\r\n      //the hash contains all of the information about the meta transaction to be called\r\n      bytes32 _hash = getHash(signer, destination, value, data, rewardToken, rewardAmount);\r\n      //increment the hash so this tx can't run again\r\n      nonce[signer]++;\r\n      //this makes sure signer signed correctly AND signer is a valid bouncer\r\n      require(signerIsWhitelisted(_hash,sig),\"BouncerProxy::forward Signer is not whitelisted\");\r\n      //make sure the signer pays in whatever token (or ether) the sender and signer agreed to\r\n      // or skip this if the sender is incentivized in other ways and there is no need for a token\r\n    //   if(rewardAmount>0){\r\n    //     //Address 0 mean reward with ETH\r\n    //     if(rewardToken==address(0)){\r\n    //       //REWARD ETHER\r\n    //       require(msg.sender.call.value(rewardAmount).gas(36000)());\r\n    //     }else{\r\n    //       //REWARD TOKEN\r\n    //       require((StandardToken(rewardToken)).transfer(msg.sender,rewardAmount));\r\n    //     }\r\n    //   }\r\n      //execute the transaction with all the given parameters\r\n      require(executeCall(destination, value, data));\r\n      emit Forwarded(sig, signer, destination, value, data, rewardToken, rewardAmount, _hash);\r\n  }\r\n  // when some frontends see that a tx is made from a bouncerproxy, they may want to parse through these events to find out who the signer was etc\r\n  event Forwarded (bytes sig, address signer, address destination, uint value, bytes data,address rewardToken, uint rewardAmount,bytes32 _hash);\r\n\r\n  // copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol\r\n  // which was copied from GnosisSafe\r\n  // https://github.com/gnosis/gnosis-safe-contracts/blob/master/contracts/GnosisSafe.sol\r\n  function executeCall(address to, uint256 value, bytes memory data) internal returns (bool success) {\r\n    assembly {\r\n       success := call(100000000000, to, value, add(data, 0x20), mload(data), 0, 0)\r\n    }\r\n  }\r\n\r\n  //borrowed from OpenZeppelin's ESDA stuff:\r\n  //https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/cryptography/ECDSA.sol\r\n  function signerIsWhitelisted(bytes32 _hash, bytes memory _signature) internal view returns (bool){\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    // Check the signature length\r\n    if (_signature.length != 65) {\r\n      return false;\r\n    }\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(_signature, 32))\r\n      s := mload(add(_signature, 64))\r\n      v := byte(0, mload(add(_signature, 96)))\r\n    }\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return false;\r\n    } else {\r\n      // solium-disable-next-line arg-overflow\r\n      return whitelist[ecrecover(keccak256(\r\n        abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash)\r\n      ), v, r, s)];\r\n    }\r\n  }\r\n}\r\n\r\n// contract StandardToken {\r\n//   function transfer(address _to,uint256 _value) public pure returns (bool) { }\r\n// }"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}